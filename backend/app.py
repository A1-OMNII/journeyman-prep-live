'''FastAPI backend to handle Stripe webhooks and license verification\nauthor: automation by assistant (no secrets included)\n'''\n\nfrom fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nimport os\nimport sqlite3\nimport uuid\nimport json\nimport time\nimport stripe\n\n# Environment config\nSTRIPE_SECRET_KEY = os.environ.get("STRIPE_SECRET_KEY")\nSTRIPE_WEBHOOK_SECRET = os.environ.get("STRIPE_WEBHOOK_SECRET")\nSENDGRID_API_KEY = os.environ.get("SENDGRID_API_KEY")\nAPP_BASE_URL = os.environ.get("APP_BASE_URL", "http://localhost:8000")\nSECRET_KEY = os.environ.get("SECRET_KEY", "changeme")\n\nif STRIPE_SECRET_KEY:\n    stripe.api_key = STRIPE_SECRET_KEY\n\nDB_PATH = os.environ.get("DATABASE_PATH", "licenses.db")\n\napp = FastAPI(title="Journeyman Prep Licensing API")\n\n# Initialize database\ndef init_db():\n    conn = sqlite3.connect(DB_PATH)\n    c = conn.cursor()\n    c.execute(\n        """\n        CREATE TABLE IF NOT EXISTS licenses (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            license_key TEXT UNIQUE,\n            email TEXT,\n            product TEXT,\n            created_at INTEGER\n        )\n        """\n    )\n    conn.commit()\n    conn.close()\n\ninit_db()\n\ndef create_license(email: str, product: str) -> str:\n    key = str(uuid.uuid4()).upper()\n    conn = sqlite3.connect(DB_PATH)\n    c = conn.cursor()\n    c.execute(\n        "INSERT INTO licenses (license_key, email, product, created_at) VALUES (?, ?, ?, ?)",\n        (key, email, product, int(time.time())),\n    )\n    conn.commit()\n    conn.close()\n    return key\n\ndef find_license(key: str):\n    conn = sqlite3.connect(DB_PATH)\n    c = conn.cursor()\n    c.execute("SELECT license_key, email, product, created_at FROM licenses WHERE license_key = ?", (key,))\n    row = c.fetchone()\n    conn.close()\n    if row:\n        return {\n            "license_key": row[0],\n            "email": row[1],\n            "product": row[2],\n            "created_at": row[3],\n        }\n    return None\n\n# Simple SendGrid email sender (optional)\ndef send_license_email(to_email: str, license_key: str, product: str):\n    if not SENDGRID_API_KEY:\n        return False\n    try:\n        from sendgrid import SendGridAPIClient\n        from sendgrid.helpers.mail import Mail\n        body = f"Thank you for your purchase.\n\nYour license key: {license_key}\n\nAccess the app and enter your license key to unlock full features.\n\n{APP_BASE_URL}"\n        message = Mail(\n            from_email='no-reply@a1omnicreations.com',\n            to_emails=to_email,\n            subject=f'Your Journeyman Prep License ({product})',\n            plain_text_content=body,\n        )\n        sg = SendGridAPIClient(SENDGRID_API_KEY)\n        sg.send(message)\n        return True\n    except Exception as e:\n        print('SendGrid error:', e)\n        return False\n\n@app.post('/webhook')\nasync def stripe_webhook(request: Request):\n    payload = await request.body()\n    sig_header = request.headers.get('stripe-signature')\n\n    event = None\n    # Verify signature if we have the webhook secret\n    if STRIPE_WEBHOOK_SECRET:\n        try:\n            event = stripe.Webhook.construct_event(\n                payload, sig_header, STRIPE_WEBHOOK_SECRET\n            )\n        except Exception as e:\n            print('Webhook signature verification failed:', e)\n            raise HTTPException(status_code=400, detail='Invalid webhook signature')\n    else:\n        try:\n            event = json.loads(payload)\n        except Exception:\n            raise HTTPException(status_code=400, detail='Invalid payload')\n\n    # Handle the checkout.session.completed event\n    if event and event.get('type') == 'checkout.session.completed':\n        data = event['data']['object']\n        customer_email = data.get('customer_details', {}).get('email') or data.get('customer_email')\n        amount_total = data.get('amount_total') or data.get('amount')\n        # product mapping by amount (amount in cents)\n        product = 'pro' if amount_total == 4900 else 'lifetime' if amount_total == 12900 else 'unknown'\n\n        if customer_email:\n            license_key = create_license(customer_email, product)\n            # send email if configured\n            send_license_email(customer_email, license_key, product)\n            return JSONResponse({"status": "ok", "license_key": license_key})\n        else:\n            return JSONResponse({"status": "ok", "note": "no email on session"})\n\n    return JSONResponse({"status": "unhandled_event"})\n\n@app.post('/verify')\nasync def verify_license(req: Request):\n    body = await req.json()\n    key = body.get('license_key')\n    if not key:\n        raise HTTPException(status_code=400, detail='license_key required')\n    row = find_license(key)\n    if row:\n        return JSONResponse({"valid": True, "email": row['email'], "product": row['product']})\n    return JSONResponse({"valid": False})\n\n@app.get('/licenses')\nasync def list_licenses(secret: str = None):\n    if secret != SECRET_KEY:\n        raise HTTPException(status_code=401, detail='unauthorized')\n    conn = sqlite3.connect(DB_PATH)\n    c = conn.cursor()\n    c.execute('SELECT license_key, email, product, created_at FROM licenses ORDER BY created_at DESC')\n    rows = c.fetchall()\n    conn.close()\n    data = [\n        {"license_key": r[0], "email": r[1], "product": r[2], "created_at": r[3]} for r in rows\n    ]\n    return JSONResponse({"licenses": data})\n\nif __name__ == '__main__':\n    import uvicorn\n    uvicorn.run(app, host='0.0.0.0', port=int(os.environ.get('PORT', 8000)))\n